ampy --port COM9 put main.py
ampy --port COM9 put boot.py
ampy --port COM9 put sensor.py

python pySimpleGUI.py

===================================================

- ESP32 Boot Module:
1. boot.py contains WiFi code.
2. WiFi starts up on boot and shows IP address.

- ESP32 Time:
1. Time is set via NTP once the device is connected to the internet.
2. NTP time is displayed in terminal on boot.

- ESP32 Sensor Class:
Sensor class contains method named moisture, which when called, returns a single dictionary containing the following data:
1. raw: the raw reading from the ADC​
2. percent: the percentage of full scale (i.e. 100 * reading / 4095)​
3. volts: the voltage level (i.e. 3.3 * reading / 4095)​
4. timestamp: the current date and time in the following format:​
    YYYY-MM-DD HH:MM:SS​ (i.e. 2019-04-15 13:52:33)

- ESP32 Main Module
1. Connects to MQTT broker.
2. Displays a message once  successfully connected.

- ESP32 JSON
Encode sensor data dictionary as JSON.

- ESP32 Publish
Publishes encoded data dictionary received from Sensor class.

- ESP32 Timer
Timer event is used to publish data every 10 seconds.

- Client Connection
Prints message once successfully connected to MQTT broker.

- Client Subscribe
Successfully subscribes to the ESP32 topic.

- Client Output
Client successfully receives and outputs nicely formatted data with timestamp:
  Raw: 2022 @ 2019-05-31  18:32:55​
  Percent: 78.0% @ 2019-05-31  18:32:55​
  Voltage: 2.755V @ 2019-05-31  18:32:55​

- Bonus 1
Publish separate topics for each of the data points (except timestamp). For example:
  mytopic/iot/moisture/raw​
  mytopic/iot/moisture/percent​
  Mytopic/iot/moisture/volts

- Bonus 2
Simple UI to display sensor readings.

========================================

Create a sensor.py module which contains a Sensor class.
This class should contain "all" your moisture sensor code.

It should have a moisture method, which returns a single dictionary containing the following:
1. raw: the raw reading from the ADC
2. percent: the percentage of full scale (i.e. 100 * reading / 4095)
3. volts: the voltage level (i.e. 3.3 * reading / 4095)
4. timestamp: the current date and time in the following format:
    YYYY-MM-DD HH:MM:SS (i.e. 2019-04-15 13:52:33)

There should be NO loops inside this class, it should simply return the dictionary whenever the moisture method is called.



Create a boot.py file for your ESP32 that does the following:
1. Connects to WiFi on startup
2. Sets the time using NTP



Create a main.py file for your ESP32 that does the following:
1. Connects to test.mosquitto.org or broker.hivemq.com with a unique client id
2. Calls the moisture method from your Sensor class every 10 seconds, to fetch the data dictionary from the ESP32 ADC
3. Encodes the dictionary as JSON
4. Publishes the JSON data under the topic of your choice
5. For additional points, also publish a separate topic for each of the data points (except timestamp), for example:
    mytopic/iot/moisture/raw
    mytopic/iot/moisture/percent
    Mytopic/iot/moisture/volts



To set the correct time on your ESP32 using NTP (network time protocol), run the following code once when it boots up, after WiFi has successfully connected

from ntptime import settime
import time
# set the time from NTP servers
settime()
# display local UTC time
time.localtime()



Please note, NTP returns UTC (or Greenwich) time, to get local Winnipeg time, we need to subtract 5 hours (depending on daylight savings time), converted to seconds
• 5 hours x 60 min/hr x 60 sec/hr = 18,000 sec

# get current UTC time
now = time.time()
# adjust to Winnipeg time (UTC - 18000sec)
year, month, day, hour, minute, sec, _, _ = time.localtime(now - 18000)



(Use timer DO NOT use while loop)
There is a main way to execute tasks on periodic intervals:
Use a hardware timer or virtual timer:
ESP32 has 4 hardware timers (id: 0-3) and 1 virtual timer (id: -1)

https://docs.micropython.org/en/latest/library/machine.Timer.html
https://docs.micropython.org/en/latest/esp32/quickref.html#timers

A simple example that uses a virtual timer to call a function every 10 seconds:

from machine import Timer
def do_stuff(tmrObj):
    print("Hello!")
tmr = Timer(-1)
tmr.init(mode=Timer.PERIODIC, period=10000, callback=do_stuff)



Create a Python3 client on your computer that will do the following:
1. Print out a success message once connected to test.mosquitto.org or broker.hivemq.com
2. Subscribe to your ESP32 topic(s)
3. Print a nicely formatted reading, with the included timestamp, every time data arrives
4. For example:
    Raw: 2022 @ 2019-05-31 18:32:55
    Percent: 78.0% @ 2019-05-31 18:32:55
    Voltage: 2.755V @ 2019-05-31 18:32:55



(Bonus)
Create a simple UI with one of the Python toolkits to display your sensor data instead of the command line
  For example:
  1. wxPython toolkit: https://www.wxpython.org/
  2. wxPython Hello World Example: https://wxpython.org/pages/overview/#hello world
  3. wxPython Widget Gallery: https://docs.wxpython.org/gallery.html
  4. wxFormBuilder tool to graphically build UI's for wxPython: https://github.com/wxFormBuilder/wxFormBuilder
You can also use the much simpler TK based UI toolkits:
  1. https://projects.raspberrypi.org/en/projects/getting started with guis
  2. https://lawsie.github.io/guizero/start/
  3. https://github.com/PySimpleGUI/PySimpleGUI


==============================================

1. a module level docstring using double quote (always)
2. a class level docstring using double quote (if a classes exist)
3. a function level docstring using double quotes (if functions exist)
4. code comments for each logical block of code (not each line!!!) using # with a space after it, either above the code block or inline, either is fine (always)
5. documentation shouldn't be too long.

here's sample documentation:

"""
This module will calculate something then do something else.
Blah blah.
"""


class Calc():
    """This class contains math functions to do blah."""

    def CalcSomething(a, b):
        """Multiplies numbers together."""
        x = a * b

        # print out result
        print(x)  # print out result

=============================================


Did you implement error handling for ALL code?


Use an overall try-except in EVERY function your write. In fact, when you write the function definition, immediately put the try-except in place before you ever write a single line of code in that function.
	
Place a try-except statement inside EVERY loop. I see some of you placing try-except statement around the outside of the loops. This has the same effect as an overall try-except in the function and does NOT prevent the program from terminating once an error occurs inside the loop.
	
Use try-except statements for ALL code in main program blocks that aren't inside a function. Aside from the import statements at the top of the program, every last single itty bitty line of code should be error handled. Every one.
	
In every except statement, put a meaningful path/location where the error occurred, so you immediately know where the problem happened. Follow the pattern: filename:classname:functionname:loop:error



This is the basic error handling I require from you for every assignment moving forward please.

For more advanced error handling, you can log the error messages to a log file, and/or even publish them to an error topic that an admin could subscribe to and see error msg's happening in real time. I don't require you to do the advanced steps for this course, unless I specifically ask you too.